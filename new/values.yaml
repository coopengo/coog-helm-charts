# Global configuration applied to all components

# -- Number of pod for all components. It can be customized for each component.
# e.g:
# coog:
#   replicaCount: 1
replicaCount: 1

# -- Strategy used to replace old pods with newest. It can be customized for each component.
# e.g:
# coog:
#   strategy:
#     type: Recreate
#
# ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
# values: Recreate or RollingUpdate 
strategy:
  type: Recreate

image:
  # -- Tag applied for all components. It can be customized for each component.
  # e.g:
  # coog:
  #   image:
  #     repository: cooghub
  repository: cooghub

  # -- Tag applied for all components. It can be customized for each component.
  # e.g:
  # coog:
  #   image:
  #     tag: coog-master-latest
  tag: coog-master-latest

  # -- Image Pull Policy applied for all components. It can be customized for each component.
  # e.g:
  # coog:
  #   image:
  #     pullPolicy: Always
  pullPolicy: Always

  # -- secret to be used to download image for all components.
  pullSecrets:
    - name: docker-registry

ingress:
  # -- Default host for the ingress record applied for all ingress. It can be customized for each component.
  # e.g:
  # coog:
  #   ingress:
  #     hosts:
  #       - host: coog.local
  #         path: /
  host: coog.local

  # Can't set key as "tls", else warning for Rabbitmq dependencie
  thisTls:
    # -- Enable TLS configuration for the host defined at `ingress.host` parameter
    # TLS certificates will be retrieved from a TLS secret with name: `{{- printf "%s-tls" .Values.ingress.host }}`
    # You can:
    #   - Create a secret with your own certificates.
    #     e.g:
    #     apiVersion: v1
    #     kind: Secret
    #     metadata:
    #       name: coog.local-tls
    #     type: kubernetes.io/tls
    #     data:
    #       server.crt: |
    #            <crt contents here>
    #       server.key: |
    #            <private key contents here>
    #   - Rely on cert-manager to create it by setting the corresponding annotations
    #
    enable: true

    letsencrypt: true
    # -- TLS configuration for additional hostname(s) to be covered with this ingress record
    # ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    # e.g:
    # configuration:
    # - hosts:
    #     - coog.local
    #   secretName: coog.local-tls
    #
    configuration: []

  # -- Default annotations applied to all ingress. It can be customized for each component
  # e.g:
  # coog:
  #   ingress:
  #     annotations: 
  #       key: value
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/send-timeout: 3600
    nginx.ingress.kubernetes.io/proxy-connect-timeout: 3600
    nginx.ingress.kubernetes.io/proxy-send-timeout: 3600
    nginx.ingress.kubernetes.io/proxy-read-timeout: 3600
    nginx.ingress.kubernetes.io/proxy-body-size: 100m
    nginx.ingress.kubernetes.io/client-body-buffer-size: 100m

  # -- Création de 3 modes de configuration :
  # trustedCidr : mettre en place les IP interne (seront autorisées automatiquement quand le mode maintenance sera actif)
  # publicCidr (global + par composant) : IP externe à autoriser + possibilité de personnaliser par composant (append) - Non pris en compte par le mode maintenance
  nginx:
    whiteList:
      trustedCidr:
        - 127.0.0.1/32
      publicCidr: []

# -- Configure options applied to all deployments, liveness, readiness and startup probes
# ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
# initialDelaySeconds: Initial delay seconds e
# periodSeconds: Period seconds
# timeoutSeconds: Timeout seconds
# failureThreshold: Failure threshold
# successThreshold: Success threshold
#
# With this configuration, the kubelet will attempt to open a socket to your container on the specified port. 
# If it can establish a connection, the container is considered healthy, if it can't it is considered a failure
livenessProbe:
  initialDelaySeconds: 15
  periodSeconds: 30
  timeoutSeconds: 30
  successThreshold: 1
  failureThreshold: 3

# -- Sometimes, applications are temporarily unable to serve traffic. 
# For example, an application might need to load large data or configuration files during startup, 
# or depend on external services after startup. In such cases, you don't want to kill the application, 
# but you don't want to send it requests either
readinessProbe:
  initialDelaySeconds: 5
  periodSeconds: 30
  timeoutSeconds: 30
  successThreshold: 1
  failureThreshold: 3

# -- additional startup time on their first initialization
startupProbe:
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 1
  failureThreshold: 30
  successThreshold: 1

# -- Node labels for pod assignment. It can be customized for each component
nodeSelector: {}

# -- Tolerations for pod assignment. It can be customized for each component
tolerations: []

# -- Affinity for pod assignment. It can be customized for each component
affinity: {}

#############################################################################################################################

quota:
  enable: false
  rollingUpdate: false
  config:
    cpuRequest: 0
    memoryRequest: 0
    cpuLimit: 0
    memoryLimit: 0

maintenanceMode:
  enable: false
  imagePullSecrets:
    - name: docker-registry
  image:
    name: nginx-custom-error-pages
    tag: latest
    pullPolicy: Always
  # Possible variables :
  # env:
  #   TEMPLATE_NAME: "coopengo"
  #   DEFAULT_ERROR_PAGE: 404
  #   DEFAULT_HTTP_CODE: 404
  #   SHOW_DETAILS: false
  #   DISABLE_L10N: false
  resources:
    limits:
      cpu: 100m
      memory: 100Mi
    requests:
      cpu: 50m
      memory: 50Mi
  ingress:
    nginx:
      customhttperrors: 403
    annotations: {}

#############################################################################################################################
# Dependencies

rabbitmq:
  enable: true
  resources:
    limits:
      cpu: 600m
      memory: 400Mi
    requests:
      cpu: 100m
      memory: 100Mi
  updateStrategyType: RollingUpdate
  extraConfiguration: |-
    consumer_timeout = 172800000
    loopback_users.guest = false
  livenessProbe:
    initialDelaySeconds: 240

mongodb:
  enable: false
  strategyType: Recreate
  replicaSet:
    enable: false
  usePassword: true
  mongodbDatabase: coog-gateway
  resources:
    limits:
      cpu: 100m
      memory: 300Mi
    requests:
      cpu: 50m
      memory: 150Mi
  volumePermissions:
    enable: true
    resources:
      limits:
        cpu: 100m
        memory: 300Mi
      requests:
        cpu: 50m
        memory: 150Mi

#############################################################################################################################
# coog components mandatory

coog:
  image:
    # -- Image repository to run coog
    name: coog

  strategy:
    type: ""

  containerPorts:
    # -- Listening port of the application in the container
    http: 8000

  # -- coog, celery and batch configuration for number of workers
  workers:
    number: 1
    maximumMemory: 512000
  
  # -- coog and celery configuration for cache
  cache:
    record: 50000
    cleanTimeOut: 0

  # -- Dynamic ConfigMap variables for coog.
  # Each value can be modified without override all or delete other parameters
  config:
    COOG_TIMEOUT: 3600
    LOG_LEVEL: INFO
    TRYTOND_DATABASE__LANGUAGE: fr
    TRYTOND_EMAIL__FROM: to_define
    TRYTOND_DEBUG__DISABLE_SYNTAX_ANALYSIS: true
    TRYTOND_BATCH__ENABLE_CELERY_AUTO_SCALING: 1
    TRYTOND_TZ: Europe/Paris
    COOG_IWC: 1

  persistentVolume:
    enable: true
    name: workspace-io
    io: /workspace/io/
    storageClass: nfs-client
    size: 10Gi
    claim:
      name: ""

  securityContext:
    runAsUser: 1000

  ingress:
    # -- Default host for the ingress resource for coog containers'
    hosts:
      - paths:
          - /
    nginx:
      whiteList:
        publicCidr: []

  # -- coog containers' resource requests and limits
  resources:
    limits:
      cpu: 1500m
      memory: 1750Mi
    requests:
      cpu: 200m
      memory: 300Mi

  initContainers:
    resources:
      limits:
        cpu: 500m
        memory: 800Mi
      requests:
        cpu: 400m
        memory: 400Mi



celery:
  workers:
    # -- Number of celery workers to run
    number: 1

  # -- Dynamic ConfigMap variables for celery
  config: {}

  # -- celery containers' resource requests and limits
  resources:
    limits:
      cpu: 400m
      memory: 1000Mi
    requests:
      cpu: 100m
      memory: 300Mi



static:
  image:
    # -- static image name
    name: coog-static

  strategy:
    # -- static redeployment strategy type
    type: ""

  ingress:
    # -- Default host for the ingress resource for static containers'
    hosts:
      - paths:
          - /sao
          - /bench
          - /doc
    nginx:
      whiteList:
        publicCidr: []


  # -- static containers' resource requests and limits
  resources:
    limits:
      cpu: 50m
      memory: 80Mi
    requests:
      cpu: 10m
      memory: 20Mi



cron:
  # -- Dynamic ConfigMap variables for cron
  config:
    TRYTOND_DEBUG__VIEWS: false

  # -- cron containers' resource requests and limits
  resources:
    limits:
      cpu: 200m
      memory: 500Mi
    requests:
      cpu: 100m
      memory: 300Mi

  # -- Configure options applied to cron deployment, liveness, readiness and startup probes
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes
  # initialDelaySeconds: Initial delay seconds e
  # periodSeconds: Period seconds
  # timeoutSeconds: Timeout seconds
  # failureThreshold: Failure threshold
  # successThreshold: Success threshold
  #
  # With this configuration, the kubelet will attempt to open a socket to your container on the specified port. 
  # If it can establish a connection, the container is considered healthy, if it can't it is considered a failure
  livenessProbe:
    initialDelaySeconds: 30
    periodSeconds: 120
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 2

  # -- additional startup time on their first initialization
  startupProbe:
    initialDelaySeconds: 30
    periodSeconds: 120
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 2
  coogCeleryModule: coog_async.coog_celery




### Optionals components
gateway:
  # -- Deploy gateway container(s)
  enable: true
  external_mongodb:
    enable: false
  mongodb:
    database: coog-gateway
  jwt:
    encryption: secret
    expiration: 3600
  whitelist:
  # -- 	Number of gateway Pods to run
  replicaCount: 1
  portal_url: coog.local
  gateway_url: coog.local
  entrypoint: "/gateway"
  extraEnv:
    COOG_TOKEN_MODULE: "false"

  image:
    # -- gateway image repository
    name: gateway
    # -- gateway image tag
    tag: coog-2.10.2048
    # -- gateway image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  ingress:
    # -- Default host for the ingress resource for coog containers'
    hosts:
      - paths:
          - /
    nginx:
      whiteList:
        publicCidr: []
      annotations:
        nginx.ingress.kubernetes.io/rewrite-target: '/$2'

  # -- gateway containers' resource requests and limits
  resources:
    limits:
      cpu: 100m
      memory: 100Mi
    requests:
      cpu: 50m
      memory: 50Mi





###########################################################

api:
  # -- Deploy api container(s)
  enable: true
  # -- 	Number of api Pods to run
  replicaCount: 1

  mongodb:
    database: coog-api-v2

  image:
    # -- api image repository
    name: api
    # -- api image tag
    tag: coog-2.10.2048
    # -- api image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  # -- api containers' resource requests and limits
  resources:
    limits:
      cpu: 500m
      memory: 100Mi
    requests:
      cpu: 50m
      memory: 50Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []


apiB2bConfig:
  # -- Deploy api_b2b_config container(s)
  enable: false
  # -- 	Number of api_b2b_config Pods to run
  replicaCount: 1

  image:
    # -- api_b2b_config image repository
    name: api-b2b-config
    # -- api_b2b_config image tag
    tag: coog-2.10.2048
    # -- api_b2b_config image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry

  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  # -- api_b2b_config containers' resource requests and limits
  resources:
    limits:
      cpu: 50m
      memory: 80Mi
    requests:
      cpu: 30m
      memory: 40Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

apiB2c:
  # -- Deploy api_b2c container(s)
  enable: false
  # -- 	Number of api_b2c Pods to run
  replicaCount: 1

  image:
    # -- api_b2c image repository
    name: api-b2c
    # -- api_b2c image tag
    tag: coog-2.10.2048
    # -- api_b2c image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  # -- api_b2c containers' resource requests and limits
  resources:
    limits:
      cpu: 50m
      memory: 50Mi
    requests:
      cpu: 20m
      memory: 25Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []


apiIdentityManager:
  # -- Deploy api_identity_manager container(s)
  enable: true
  # -- 	Number of api_identity_manager Pods to run
  replicaCount: 1

  image:
    # -- api-identity-manager image repository
    name: api-identity-manager
    # -- api-identity-manager image tag
    tag: coog-2.10.2048
    # -- api-identity-manager image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  # -- api_identity_manager containers' resource requests and limits
  resources:
    limits:
      cpu: 50m
      memory: 70Mi
    requests:
      cpu: 10m
      memory: 30Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []


apiReferential:
  # -- Deploy api_referential container(s)
  enable: false
  # -- 	Number of api_referential Pods to run
  replicaCount: 1

  image:
    # -- api_referential image repository
    name: api-referential
    # -- api_referential image tag
    tag: coog-2.10.2048
    # -- api_referential image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  # -- api_referential containers' resource requests and limits
  resources:
    limits:
      cpu: 200m
      memory: 400Mi
    requests:
      cpu: 100m
      memory: 250Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []


appB2c:
  # -- Deploy app_b2c container(s)
  enable: false
  # -- 	Number of app_b2c Pods to run
  replicaCount: 1

  image:
    # -- app_b2c image repository
    name: app-b2c
    # -- app_b2c image tag
    tag: coog-2.10.2048
    # -- app_b2c image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  ingress:
    # -- Enable ingress controller resource for app_b2c containers'
    enable: false
    # -- Ingress annotations for app_b2c containers'
    annotations: {}
      # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # -- Default host for the ingress resource for app_b2c containers'
    hosts:
      - host: app-b2c.local
        paths: []
    # -- TLS configuration for app_b2c containers'
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  # -- app_b2c containers' resource requests and limits
  resources:
    limits:
      cpu: 50m
      memory: 50Mi
    requests:
      cpu: 10m
      memory: 30Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []


unoconv:
  # -- Deploy unoconv container(s)
  enable: true
  # -- 	Number of unoconv Pods to run
  replicaCount: 1

  image:
    # -- unoconv image repository
    name: unoconv
    # -- unoconv image tag
    tag: dgw-0.0.1
    # -- unoconv image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 5000

  # -- unoconv containers' resource requests and limits
  resources:
    limits:
      cpu: 300m
      memory: 300Mi
    requests:
      cpu: 50m
      memory: 50Mi

  # -- Affinity for pod assignment
  affinity: {}

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  livenessProbe:
    initialDelaySeconds: 0
    periodSeconds: 60
    timeoutSeconds: 30
    successThreshold: 1
    failureThreshold: 1
  readinessProbe:
    initialDelaySeconds: 0
    periodSeconds: 30
    timeoutSeconds: 30
    successThreshold: 1
    failureThreshold: 3


web:
  # -- Deploy web container(s)
  enable: true
  # -- 	Number of web Pods to run
  replicaCount: 1

  image:
    # -- web image repository
    name: web
    # -- web image tag
    tag: coog-2.10.2048
    # -- web image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  ingress:
    # -- Enable ingress controller resource for web containers'
    enable: false
    # -- Ingress annotations for web containers'
    annotations: {}
      # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # -- Default host for the ingress resource for web containers'
    hosts:
      - host: web.local
        paths: []
    # -- TLS configuration for web containers'
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
    nginx:
      rewritetarget: '/$2'

  livenessProbe:
    periodSeconds: 60
    timeoutSeconds: 30

  # -- web containers' resource requests and limits
  resources:
    limits:
      cpu: 500m
      memory: 200Mi
    requests:
      cpu: 30m
      memory: 30Mi

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}

b2b:
  # -- Deploy portal container(s)
  enable: false
  # -- 	Number of portal Pods to run
  replicaCount: 1

  image:
    # -- portal image repository
    name: portal
    # -- portal image tag
    tag: coog-2.10.2048
    # -- portal image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  ingress:
    # -- Enable ingress controller resource for portal containers'
    enable: false
    # -- Ingress annotations for portal containers'
    annotations: {}
      # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # -- Default host for the ingress resource for portal containers'
    hosts:
      - host: portal.local
        paths: []
    # -- TLS configuration for portal containers'
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  # -- portal containers' resource requests and limits
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 250m
      memory: 50Mi
    requests:
      cpu: 10m
      memory: 25Mi

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}

jwt:
  internal:
    encryption: changeme

batch:
  migquottosr:
    enable: false
    image:
      pullPolicy: Always
      name: migquottosr
      tags: latest
    schedule: "0 20 * * *"
    imagePullSecrets:
      - name: docker-registry
    resources:
      limits:
        cpu: 200m
        memory: 100Mi
      requests:
        cpu: 100m
        memory: 50Mi

# B2C Frontend
customerFrontend:
  # -- Deploy portal container(s)
  enable: false
  # -- 	Number of portal Pods to run
  replicaCount: 1

  image:
    # -- portal image repository
    name: coog-customer-frontend
    # -- portal image tag
    tag: coog-2.13.2137
    # -- portal image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  ingress:
    # -- Enable ingress controller resource for portal containers'
    enable: true
    # -- Ingress annotations for portal containers'
    annotations: {}
      # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # -- Default host for the ingress resource for portal containers'
    hosts:
      - host: customer.local
        paths: []
    # -- TLS configuration for portal containers'
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  # -- portal containers' resource requests and limits
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 100m
      memory: 100Mi
    requests:
      cpu: 50m
      memory: 50Mi

  initContainers:
    resources:
      limits:
        cpu: 400m
        memory: 2000Mi
      requests:
        cpu: 200m
        memory: 1500Mi

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}

# B2C Backend
customerBackend:
  # -- Deploy portal container(s)
  enable: false
  # -- 	Number of portal Pods to run
  replicaCount: 1
  postgres_db: 'strapi'

  image:
    # -- portal image repository
    name: coog-customer-backend
    # -- portal image tag
    tag: coog-2.13.2137
    # -- portal image pull policy
    pullPolicy: Always

  # -- Specify docker-registry secret names as an array
  imagePullSecrets:
    - name: docker-registry
  nameOverride: ""
  fullnameOverride: ""

  service:
    type: ClusterIP
    port: 80

  ingress:
    # -- Enable ingress controller resource for portal containers'
    enable: true
    # -- Ingress annotations for portal containers'
    annotations: {}
      # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # -- Default host for the ingress resource for portal containers'
    hosts:
      - host: v1.customer.local
        paths: []
    # -- TLS configuration for portal containers'
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  # -- portal containers' resource requests and limits
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits:
      cpu: 400m
      memory: 300Mi
    requests:
      cpu: 100m
      memory: 150Mi

  initContainers:
    resources:
      limits:
        cpu: 400m
        memory: 500Mi
      requests:
        cpu: 200m
        memory: 250Mi

  # -- Node labels for pod assignment
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}
